package paillier

import (
	"math/big"
	"testing"
)

func TestPublicKey_BatchAdd(t *testing.T) {
	pk, sk, err := GenerateKeyPair(1024)
	if err != nil {
		t.Errorf("Error generating key pair")
		return
	}
	ct2, _ := pk.Encrypt(2)
	ct3, _ := pk.Encrypt(3)
	ct4, _ := pk.Encrypt(4)
	ct5, _ := pk.Encrypt(5)

	tests := []struct {
		name string
		args []*big.Int
		want int64
	}{
		{
			"sum 2..4",
			[]*big.Int{ct2, ct3, ct4},
			9,
		},
		{
			"sum 4..5",
			[]*big.Int{ct4, ct5},
			9,
		},
		{
			"sum 2..5",
			[]*big.Int{ct2, ct3, ct4, ct5},
			14,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := pk.BatchAdd(tt.args...)

			// Test the homomorphic property
			sum, err := sk.Decrypt(got)
			if err != nil {
				t.Errorf("PublicKey.Add() error = invalid ciphertext generated by addition")
				return
			}
			if sum != tt.want {
				t.Errorf("PublicKey.Add() = %v, want %v", sum, tt.want)
			}
		})
	}
}

func TestPublicKey_EncryptWithWithSGP(t *testing.T) {
	pk, sk, _ := GenerateKeyPair(1024)

	tests := []struct {
		name    string
		msg     int64
		wantErr bool
	}{
		{
			"cipher positive value, must return valid ciphertext",
			1,
			false,
		},
		{
			"cipher zero value, must return valid ciphertext",
			0,
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ct := pk.EncryptWithWithSGP(tt.msg)
			if ct.Cmp(zero) != 1 {
				t.Errorf("PublicKey.EncryptWithWithSGP() error - invalid ciphertext")
				return
			}
			pt, err := sk.Decrypt(ct)
			if err != nil {
				t.Errorf("PublicKey.EncryptWithWithSGP() error - cannot decipher ciphertext")
				return
			}
			if pt != tt.msg {
				t.Errorf("PublicKey.EncryptWithWithSGP() error = ciphertext does not decipher to the original message (%v, %v)", pt, tt.msg)
				return
			}
		})
	}
}
